"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commands = void 0;
const AdminApiClient_1 = require("./AdminApiClient");
const helpers_1 = require("./helpers");
function commands(Cyp, CypCy) {
    const logIsEnabled = !(0, helpers_1.isFalsy)(Cyp.env(helpers_1.LOG_ENVIRONMENT_VAR));
    const defaultApiClient = new AdminApiClient_1.AdminApiClient({
        enabled: Cyp.env(helpers_1.ENABLED_ENVIRONMENT_VAR),
        port: Cyp.env(helpers_1.ADMIN_API_PORT_ENVIRONMENT_VAR),
        host: Cyp.env(helpers_1.ADMIN_API_HOST_ENVIRONMENT_VAR),
        https: (0, helpers_1.isTruthy)(Cyp.env(helpers_1.ADMIN_API_HTTPS_ENVIRONMENT_VAR)),
    });
    function getClient(apiClient) {
        return apiClient || defaultApiClient;
    }
    function handlePromise(promise) {
        return new Cyp.Promise((resolve) => {
            promise.then(() => {
                resolve();
            }).catch((error) => {
                resolve(error);
            });
        });
    }
    function log(message, rest) {
        if (logIsEnabled) {
            CypCy.log(message, ...rest);
        }
    }
    function ensureLogsArray(logs) {
        if (!logs) {
            return [];
        }
        return Array.isArray(logs) ? logs : [logs];
    }
    function logMessages(messages, extraMessages) {
        const messagesArray = ensureLogsArray(messages);
        log(`[Mocks Server] ${messagesArray[0]}`, [...messagesArray.slice(1), ...ensureLogsArray(extraMessages)]);
    }
    function doRequestAndLog(client, clientCommand, successMessages, errorMessages) {
        CypCy.wrap(handlePromise(clientCommand), { log: false }).then((error) => {
            if (error) {
                logMessages(errorMessages, `Error: ${error.message}`);
                if (error.message.includes("Network")) {
                    logMessages(`You should check if the Admin API is listening on ${client.url}`);
                }
            }
            else {
                logMessages(successMessages);
            }
        });
    }
    function setCollection(id, apiClient) {
        const client = getClient(apiClient);
        doRequestAndLog(client, client.updateConfig({
            mock: {
                collections: { selected: id },
            },
        }), `Collection changed to '${id}'`, `Error trying to change collection to '${id}'`);
    }
    function setDelay(delay, apiClient) {
        const client = getClient(apiClient);
        doRequestAndLog(client, client.updateConfig({
            mock: {
                routes: { delay },
            },
        }), `Delay changed to '${delay}'`, `Error trying to change delay to '${delay}'`);
    }
    function setConfig(mocksServerConfig, apiClient) {
        const client = getClient(apiClient);
        const configMessage = JSON.stringify(mocksServerConfig);
        doRequestAndLog(client, client.updateConfig(mocksServerConfig), [`Configuration changed`, configMessage], [`Error trying to change configuration`, configMessage]);
    }
    function useRouteVariant(id, apiClient) {
        const client = getClient(apiClient);
        doRequestAndLog(client, client.useRouteVariant(id), `Collection now is using custom route variant '${id}'`, `Error trying to set route variant '${id}'`);
    }
    function restoreRouteVariants(apiClient) {
        const client = getClient(apiClient);
        doRequestAndLog(client, client.restoreRouteVariants(), `Collection route variants restored`, `Error trying to restore collection route variants`);
    }
    function configClient(customConfig, apiClient) {
        return getClient(apiClient).configClient(customConfig);
    }
    return {
        setCollection,
        setDelay,
        setConfig,
        useRouteVariant,
        restoreRouteVariants,
        configClient,
    };
}
exports.commands = commands;
